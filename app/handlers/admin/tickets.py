import logging
import re
from typing import List, Dict, Any
from aiogram import Dispatcher, types, F, Bot
from aiogram.fsm.context import FSMContext
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, desc, and_
from datetime import datetime, timedelta
import time

from app.database.models import User, Ticket, TicketStatus
from app.database.crud.ticket import TicketCRUD, TicketMessageCRUD
from app.states import TicketStates, AdminTicketStates
from app.keyboards.inline import (
    get_admin_tickets_keyboard,
    get_admin_ticket_view_keyboard,
    get_admin_ticket_reply_cancel_keyboard
)
from app.localization.texts import get_texts
from app.utils.pagination import paginate_list, get_pagination_info
from app.services.admin_notification_service import AdminNotificationService
from app.config import settings
from app.utils.cache import RateLimitCache

logger = logging.getLogger(__name__)



def extract_id_from_callback(callback_data: str) -> int:
    """–ò–∑–≤–ª–µ–∫–∞–µ—Ç —á–∏—Å–ª–æ–≤–æ–π –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –∏–∑ callback_data."""
    match = re.search(r"(\d+)$", callback_data or "")
    if not match:
        raise ValueError(f"ID not found in callback data: {callback_data}")
    return int(match.group(1))


 


async def show_admin_tickets(
    callback: types.CallbackQuery,
    db_user: User,
    db: AsyncSession
):
    """–ü–æ–∫–∞–∑–∞—Ç—å –≤—Å–µ —Ç–∏–∫–µ—Ç—ã –¥–ª—è –∞–¥–º–∏–Ω–æ–≤"""
    texts = get_texts(db_user.language)
    
    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–µ–∫—É—â—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É –∏ scope
    current_page = 1
    scope = "open"
    data_str = callback.data
    if data_str == "admin_tickets_scope_open":
        scope = "open"
    elif data_str == "admin_tickets_scope_closed":
        scope = "closed"
    elif data_str.startswith("admin_tickets_page_"):
        try:
            parts = data_str.split("_")
            # format: admin_tickets_page_{scope}_{page}
            if len(parts) >= 5:
                scope = parts[3]
                current_page = int(parts[4])
            else:
                current_page = int(data_str.replace("admin_tickets_page_", ""))
        except ValueError:
            current_page = 1
    statuses = [TicketStatus.OPEN.value, TicketStatus.ANSWERED.value] if scope == "open" else [TicketStatus.CLOSED.value]
    page_size = 10
    # total count for proper pagination
    total_count = await TicketCRUD.count_tickets_by_statuses(db, statuses)
    total_pages = max(1, (total_count + page_size - 1) // page_size) if total_count > 0 else 1
    if current_page > total_pages:
        current_page = total_pages
    offset = (current_page - 1) * page_size
    tickets = await TicketCRUD.get_tickets_by_statuses(db, statuses=statuses, limit=page_size, offset=offset)
    
    # –î–∞–∂–µ –µ—Å–ª–∏ —Ç–∏–∫–µ—Ç–æ–≤ –Ω–µ—Ç, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–µ—Ä–µ–∫–ª—é—á–∞—Ç–µ–ª–∏ —Ä–∞–∑–¥–µ–ª–æ–≤
    
    # –§–æ—Ä–º–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã
    ticket_data = []
    for ticket in tickets:
        user_name = ticket.user.full_name if ticket.user else "Unknown"
        ticket_data.append({
            'id': ticket.id,
            'title': ticket.title,
            'status_emoji': ticket.status_emoji,
            'priority_emoji': ticket.priority_emoji,
            'user_name': user_name,
            'is_closed': ticket.is_closed,
            'locked_emoji': ("üîí" if ticket.is_user_reply_blocked else "")
        })
    
    # –ò—Ç–æ–≥–æ–≤—ã–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã —É–∂–µ –ø–æ—Å—á–∏—Ç–∞–Ω—ã –≤—ã—à–µ
    await callback.message.edit_text(
        texts.t("ADMIN_TICKETS_TITLE", "üé´ –í—Å–µ —Ç–∏–∫–µ—Ç—ã –ø–æ–¥–¥–µ—Ä–∂–∫–∏:"),
        reply_markup=get_admin_tickets_keyboard(ticket_data, current_page=current_page, total_pages=total_pages, language=db_user.language, scope=scope)
    )
    await callback.answer()


async def view_admin_ticket(
    callback: types.CallbackQuery,
    db_user: User,
    db: AsyncSession,
    state: FSMContext
):
    """–ü–æ–∫–∞–∑–∞—Ç—å –¥–µ—Ç–∞–ª–∏ —Ç–∏–∫–µ—Ç–∞ –¥–ª—è –∞–¥–º–∏–Ω–∞"""
    texts = get_texts(db_user.language)
    try:
        ticket_id = extract_id_from_callback(callback.data)
    except ValueError:
        await callback.answer(
            texts.t("TICKET_NOT_FOUND", "–¢–∏–∫–µ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω."),
            show_alert=True
        )
        return

    ticket = await TicketCRUD.get_ticket_by_id(db, ticket_id, load_messages=True, load_user=True)

    if not ticket:
        await callback.answer(
            texts.t("TICKET_NOT_FOUND", "–¢–∏–∫–µ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω."),
            show_alert=True
        )
        return
    
    texts = get_texts(db_user.language)
    
    # –§–æ—Ä–º–∏—Ä—É–µ–º —Ç–µ–∫—Å—Ç —Ç–∏–∫–µ—Ç–∞
    status_text = {
        TicketStatus.OPEN.value: texts.t("TICKET_STATUS_OPEN", "–û—Ç–∫—Ä—ã—Ç"),
        TicketStatus.ANSWERED.value: texts.t("TICKET_STATUS_ANSWERED", "–û—Ç–≤–µ—á–µ–Ω"),
        TicketStatus.CLOSED.value: texts.t("TICKET_STATUS_CLOSED", "–ó–∞–∫—Ä—ã—Ç"),
        TicketStatus.PENDING.value: texts.t("TICKET_STATUS_PENDING", "–í –æ–∂–∏–¥–∞–Ω–∏–∏")
    }.get(ticket.status, ticket.status)
    
    user_name = ticket.user.full_name if ticket.user else "Unknown"
    
    ticket_text = f"üé´ –¢–∏–∫–µ—Ç #{ticket.id}\n\n"
    ticket_text += f"üë§ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {user_name}\n"
    ticket_text += f"üìù –ó–∞–≥–æ–ª–æ–≤–æ–∫: {ticket.title}\n"
    ticket_text += f"üìä –°—Ç–∞—Ç—É—Å: {ticket.status_emoji} {status_text}\n"
    ticket_text += f"üìÖ –°–æ–∑–¥–∞–Ω: {ticket.created_at.strftime('%d.%m.%Y %H:%M')}\n"
    ticket_text += f"üîÑ –û–±–Ω–æ–≤–ª–µ–Ω: {ticket.updated_at.strftime('%d.%m.%Y %H:%M')}\n\n"
    
    if ticket.is_user_reply_blocked:
        if ticket.user_reply_block_permanent:
            ticket_text += "üö´ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω –Ω–∞–≤—Å–µ–≥–¥–∞ –¥–ª—è –æ—Ç–≤–µ—Ç–æ–≤ –≤ —ç—Ç–æ–º —Ç–∏–∫–µ—Ç–µ\n"
        elif ticket.user_reply_block_until:
            ticket_text += f"‚è≥ –ë–ª–æ–∫ –¥–æ: {ticket.user_reply_block_until.strftime('%d.%m.%Y %H:%M')}\n"
    
    if ticket.messages:
        ticket_text += f"üí¨ –°–æ–æ–±—â–µ–Ω–∏—è ({len(ticket.messages)}):\n\n"
        
        for msg in ticket.messages:
            sender = "üë§ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å" if msg.is_user_message else "üõ†Ô∏è –ü–æ–¥–¥–µ—Ä–∂–∫–∞"
            ticket_text += f"{sender} ({msg.created_at.strftime('%d.%m %H:%M')}):\n"
            ticket_text += f"{msg.message_text}\n\n"
            if getattr(msg, "has_media", False) and getattr(msg, "media_type", None) == "photo":
                ticket_text += "üìé –í–ª–æ–∂–µ–Ω–∏–µ: —Ñ–æ—Ç–æ\n\n"
    
    # –î–æ–±–∞–≤–∏–º –∫–Ω–æ–ø–∫—É "–í–ª–æ–∂–µ–Ω–∏—è", –µ—Å–ª–∏ –µ—Å—Ç—å —Ñ–æ—Ç–æ
    has_photos = any(getattr(m, "has_media", False) and getattr(m, "media_type", None) == "photo" for m in ticket.messages or [])
    keyboard = get_admin_ticket_view_keyboard(
        ticket_id, 
        ticket.is_closed, 
        db_user.language
    )
    if has_photos:
        try:
            keyboard.inline_keyboard.insert(0, [types.InlineKeyboardButton(text=texts.t("TICKET_ATTACHMENTS", "üìé –í–ª–æ–∂–µ–Ω–∏—è"), callback_data=f"admin_ticket_attachments_{ticket_id}")])
        except Exception:
            pass

    # –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º –æ—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å; –µ—Å–ª–∏ –Ω–µ –≤—ã—à–ª–æ ‚Äî —É–¥–∞–ª–∏–º –∏ –æ—Ç–ø—Ä–∞–≤–∏–º –Ω–æ–≤–æ–µ
    try:
        await callback.message.edit_text(
            ticket_text,
            reply_markup=keyboard,
        )
    except Exception:
        try:
            await callback.message.delete()
        except Exception:
            pass
        await callback.message.answer(
            ticket_text,
            reply_markup=keyboard,
        )
    # —Å–æ—Ö—Ä–∞–Ω—è–µ–º id –¥–ª—è –¥–∞–ª—å–Ω–µ–π—à–∏—Ö –¥–µ–π—Å—Ç–≤–∏–π (–æ—Ç–≤–µ—Ç/—Å—Ç–∞—Ç—É—Å—ã)
    await state.update_data(ticket_id=ticket_id)
    await callback.answer()


async def reply_to_admin_ticket(
    callback: types.CallbackQuery,
    state: FSMContext,
    db_user: User
):
    """–ù–∞—á–∞—Ç—å –æ—Ç–≤–µ—Ç –Ω–∞ —Ç–∏–∫–µ—Ç –æ—Ç –∞–¥–º–∏–Ω–∞"""
    try:
        ticket_id = extract_id_from_callback(callback.data)
    except ValueError:
        texts = get_texts(db_user.language)
        await callback.answer(
            texts.t("TICKET_NOT_FOUND", "–¢–∏–∫–µ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω."),
            show_alert=True
        )
        return

    await state.update_data(ticket_id=ticket_id, reply_mode=True)
    texts = get_texts(db_user.language)
    await callback.message.edit_text(
        texts.t("ADMIN_TICKET_REPLY_INPUT", "–í–≤–µ–¥–∏—Ç–µ –æ—Ç–≤–µ—Ç –æ—Ç –ø–æ–¥–¥–µ—Ä–∂–∫–∏:"),
        reply_markup=get_admin_ticket_reply_cancel_keyboard(db_user.language)
    )

    await state.set_state(AdminTicketStates.waiting_for_reply)
    await callback.answer()


async def handle_admin_ticket_reply(
    message: types.Message,
    state: FSMContext,
    db_user: User,
    db: AsyncSession
):
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º —Å–æ—Å—Ç–æ—è–Ω–∏–∏
    current_state = await state.get_state()
    if current_state != AdminTicketStates.waiting_for_reply:
        return

    # –ê–Ω—Ç–∏-—Å–ø–∞–º: –æ–¥–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –∑–∞ –∫–æ—Ä–æ—Ç–∫–æ–µ –æ–∫–Ω–æ –ø–æ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–º—É —Ç–∏–∫–µ—Ç—É
    try:
        data_rl = await state.get_data()
        rl_ticket_id = data_rl.get("ticket_id") or "admin_reply"
        limited = await RateLimitCache.is_rate_limited(db_user.id, f"admin_ticket_reply_{rl_ticket_id}", limit=1, window=2)
        if limited:
            return
    except Exception:
        pass
    try:
        data_rl = await state.get_data()
        last_ts = data_rl.get("admin_rl_ts_reply")
        now_ts = time.time()
        if last_ts and (now_ts - float(last_ts)) < 2:
            return
        await state.update_data(admin_rl_ts_reply=now_ts)
    except Exception:
        pass

    """–û–±—Ä–∞–±–æ—Ç–∞—Ç—å –æ—Ç–≤–µ—Ç –∞–¥–º–∏–Ω–∞ –Ω–∞ —Ç–∏–∫–µ—Ç"""
    # –ü–æ–¥–¥–µ—Ä–∂–∫–∞ —Ñ–æ—Ç–æ –≤–ª–æ–∂–µ–Ω–∏–π –≤ –æ—Ç–≤–µ—Ç–µ –∞–¥–º–∏–Ω–∞
    reply_text = (message.text or message.caption or "").strip()
    if len(reply_text) > 400:
        reply_text = reply_text[:400]
    media_type = None
    media_file_id = None
    media_caption = None
    if message.photo:
        media_type = "photo"
        media_file_id = message.photo[-1].file_id
        media_caption = message.caption

    if len(reply_text) < 1 and not media_file_id:
        texts = get_texts(db_user.language)
        await message.answer(
            texts.t("TICKET_REPLY_TOO_SHORT", "–û—Ç–≤–µ—Ç –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å –º–∏–Ω–∏–º—É–º 5 —Å–∏–º–≤–æ–ª–æ–≤. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑:")
        )
        return

    data = await state.get_data()
    ticket_id = data.get("ticket_id")
    try:
        ticket_id = int(ticket_id) if ticket_id is not None else None
    except (TypeError, ValueError):
        ticket_id = None

    if not ticket_id:
        texts = get_texts(db_user.language)
        await message.answer(
            texts.t("TICKET_REPLY_ERROR", "–û—à–∏–±–∫–∞: –Ω–µ –Ω–∞–π–¥–µ–Ω ID —Ç–∏–∫–µ—Ç–∞.")
        )
        await state.clear()
        return

    try:
        # –ï—Å–ª–∏ —ç—Ç–æ —Ä–µ–∂–∏–º –≤–≤–æ–¥–∞ –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏
        if not data.get("reply_mode"):
            try:
                minutes = int(reply_text)
                minutes = max(1, min(60*24*365, minutes))
            except ValueError:
                await message.answer("‚ùå –í–≤–µ–¥–∏—Ç–µ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ –º–∏–Ω—É—Ç")
                return
            until = datetime.utcnow() + timedelta(minutes=minutes)
            ok = await TicketCRUD.set_user_reply_block(db, ticket_id, permanent=False, until=until)
            if ok:
                await message.answer(f"‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω –Ω–∞ {minutes} –º–∏–Ω—É—Ç")
            else:
                await message.answer("‚ùå –û—à–∏–±–∫–∞ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏")
            await state.clear()
            return

        # –û–±—ã—á–Ω—ã–π —Ä–µ–∂–∏–º –æ—Ç–≤–µ—Ç–∞ –∞–¥–º–∏–Ω–∞
        ticket = await TicketCRUD.get_ticket_by_id(db, ticket_id, load_messages=False)
        if not ticket:
            texts = get_texts(db_user.language)
            await message.answer(
                texts.t("TICKET_NOT_FOUND", "–¢–∏–∫–µ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω.")
            )
            await state.clear()
            return

        # –î–æ–±–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç –∞–¥–º–∏–Ω–∞ (–≤–Ω—É—Ç—Ä–∏ add_message —Å—Ç–∞—Ç—É—Å —Å—Ç–∞–Ω–µ—Ç ANSWERED)
        await TicketMessageCRUD.add_message(
            db,
            ticket_id,
            db_user.id,
            reply_text,
            is_from_admin=True,
            media_type=media_type,
            media_file_id=media_file_id,
            media_caption=media_caption,
        )

        texts = get_texts(db_user.language)

        await message.answer(
            texts.t("ADMIN_TICKET_REPLY_SENT", "‚úÖ –û—Ç–≤–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω!"),
            reply_markup=types.InlineKeyboardMarkup(inline_keyboard=[
                [types.InlineKeyboardButton(
                    text=texts.t("VIEW_TICKET", "üëÅÔ∏è –ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Ç–∏–∫–µ—Ç"),
                    callback_data=f"admin_view_ticket_{ticket_id}"
                )],
                [types.InlineKeyboardButton(
                    text=texts.t("BACK_TO_TICKETS", "‚¨ÖÔ∏è –ö —Ç–∏–∫–µ—Ç–∞–º"),
                    callback_data="admin_tickets"
                )]
            ])
        )

        await state.clear()

        # –£–≤–µ–¥–æ–º–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –æ –Ω–æ–≤–æ–º –æ—Ç–≤–µ—Ç–µ
        await notify_user_about_ticket_reply(message.bot, ticket, reply_text, db)
        # –ê–¥–º–∏–Ω-—É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –æ—Ç–≤–µ—Ç–µ –≤ —Ç–∏–∫–µ—Ç –æ—Ç–∫–ª—é—á–µ–Ω—ã –ø–æ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—é

    except Exception as e:
        logger.error(f"Error adding admin ticket reply: {e}")
        texts = get_texts(db_user.language)
        await message.answer(
            texts.t("TICKET_REPLY_ERROR", "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –æ—Ç–≤–µ—Ç–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")
        )


async def mark_ticket_as_answered(
    callback: types.CallbackQuery,
    db_user: User,
    db: AsyncSession
):
    """–û—Ç–º–µ—Ç–∏—Ç—å —Ç–∏–∫–µ—Ç –∫–∞–∫ –æ—Ç–≤–µ—á–µ–Ω–Ω—ã–π"""
    try:
        ticket_id = extract_id_from_callback(callback.data)
    except ValueError:
        texts = get_texts(db_user.language)
        await callback.answer(
            texts.t("TICKET_UPDATE_ERROR", "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Ç–∏–∫–µ—Ç–∞."),
            show_alert=True
        )
        return
    
    try:
        success = await TicketCRUD.update_ticket_status(
            db, ticket_id, TicketStatus.ANSWERED.value
        )
        
        if success:
            texts = get_texts(db_user.language)
            await callback.answer(
                texts.t("TICKET_MARKED_ANSWERED", "‚úÖ –¢–∏–∫–µ—Ç –æ—Ç–º–µ—á–µ–Ω –∫–∞–∫ –æ—Ç–≤–µ—á–µ–Ω–Ω—ã–π."),
                show_alert=True
            )
            
            # –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
            await view_admin_ticket(callback, db_user, db)
        else:
            texts = get_texts(db_user.language)
            await callback.answer(
                texts.t("TICKET_UPDATE_ERROR", "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Ç–∏–∫–µ—Ç–∞."),
                show_alert=True
            )
            
    except Exception as e:
        logger.error(f"Error marking ticket as answered: {e}")
        texts = get_texts(db_user.language)
        await callback.answer(
            texts.t("TICKET_UPDATE_ERROR", "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Ç–∏–∫–µ—Ç–∞."),
            show_alert=True
        )


async def close_admin_ticket(
    callback: types.CallbackQuery,
    db_user: User,
    db: AsyncSession
):
    """–ó–∞–∫—Ä—ã—Ç—å —Ç–∏–∫–µ—Ç –∞–¥–º–∏–Ω–æ–º"""
    try:
        ticket_id = extract_id_from_callback(callback.data)
    except ValueError:
        texts = get_texts(db_user.language)
        await callback.answer(
            texts.t("TICKET_CLOSE_ERROR", "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏ —Ç–∏–∫–µ—Ç–∞."),
            show_alert=True
        )
        return

    try:
        success = await TicketCRUD.close_ticket(db, ticket_id)
        
        if success:
            texts = get_texts(db_user.language)
            await callback.answer(
                texts.t("TICKET_CLOSED", "‚úÖ –¢–∏–∫–µ—Ç –∑–∞–∫—Ä—ã—Ç."),
                show_alert=True
            )
            
            # –û–±–Ω–æ–≤–ª—è–µ–º inline-–∫–ª–∞–≤–∏–∞—Ç—É—Ä—É –≤ —Ç–µ–∫—É—â–µ–º —Å–æ–æ–±—â–µ–Ω–∏–∏ –±–µ–∑ –∫–Ω–æ–ø–æ–∫ –¥–µ–π—Å—Ç–≤–∏–π
            await callback.message.edit_reply_markup(
                reply_markup=get_admin_ticket_view_keyboard(ticket_id, True, db_user.language)
            )
        else:
            texts = get_texts(db_user.language)
            await callback.answer(
                texts.t("TICKET_CLOSE_ERROR", "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏ —Ç–∏–∫–µ—Ç–∞."),
                show_alert=True
            )
            
    except Exception as e:
        logger.error(f"Error closing admin ticket: {e}")
        texts = get_texts(db_user.language)
        await callback.answer(
            texts.t("TICKET_CLOSE_ERROR", "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏ —Ç–∏–∫–µ—Ç–∞."),
            show_alert=True
        )


async def cancel_admin_ticket_reply(
    callback: types.CallbackQuery,
    state: FSMContext,
    db_user: User
):
    """–û—Ç–º–µ–Ω–∏—Ç—å –æ—Ç–≤–µ—Ç –∞–¥–º–∏–Ω–∞ –Ω–∞ —Ç–∏–∫–µ—Ç"""
    await state.clear()
    
    texts = get_texts(db_user.language)
    
    await callback.message.edit_text(
        texts.t("TICKET_REPLY_CANCELLED", "–û—Ç–≤–µ—Ç –æ—Ç–º–µ–Ω–µ–Ω."),
        reply_markup=types.InlineKeyboardMarkup(inline_keyboard=[
            [types.InlineKeyboardButton(
                text=texts.t("BACK_TO_TICKETS", "‚¨ÖÔ∏è –ö —Ç–∏–∫–µ—Ç–∞–º"),
                callback_data="admin_tickets"
            )]
        ])
    )
    await callback.answer()


async def block_user_in_ticket(
    callback: types.CallbackQuery,
    state: FSMContext,
    db_user: User,
    db: AsyncSession
):
    texts = get_texts(db_user.language)
    try:
        ticket_id = extract_id_from_callback(callback.data)
    except ValueError:
        await callback.answer(texts.t("TICKET_NOT_FOUND", "–¢–∏–∫–µ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω."), show_alert=True)
        return
    await callback.message.edit_text(
        texts.t("ENTER_BLOCK_MINUTES", "–í–≤–µ–¥–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –º–∏–Ω—É—Ç –¥–ª—è –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–Ω–∞–ø—Ä–∏–º–µ—Ä, 15):"),
        reply_markup=types.InlineKeyboardMarkup(inline_keyboard=[
            [types.InlineKeyboardButton(
                text=texts.t("CANCEL_REPLY", "‚ùå –û—Ç–º–µ–Ω–∏—Ç—å –æ—Ç–≤–µ—Ç"),
                callback_data="cancel_admin_ticket_reply"
            )]
        ])
    )
    await state.update_data(ticket_id=ticket_id)
    await state.set_state(AdminTicketStates.waiting_for_block_duration)
    await callback.answer()


async def handle_admin_block_duration_input(
    message: types.Message,
    state: FSMContext,
    db_user: User,
    db: AsyncSession
):
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    current_state = await state.get_state()
    if current_state != AdminTicketStates.waiting_for_block_duration:
        return
    
    reply_text = message.text.strip()
    if len(reply_text) < 1:
        await message.answer("‚ùå –í–≤–µ–¥–∏—Ç–µ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ –º–∏–Ω—É—Ç")
        return
    
    data = await state.get_data()
    ticket_id = data.get("ticket_id")
    try:
        minutes = int(reply_text)
        minutes = max(1, min(60*24*365, minutes))  # –º–∞–∫—Å–∏–º—É–º 1 –≥–æ–¥
    except ValueError:
        await message.answer("‚ùå –í–≤–µ–¥–∏—Ç–µ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ –º–∏–Ω—É—Ç")
        return
    
    if not ticket_id:
        texts = get_texts(db_user.language)
        await message.answer(texts.t("TICKET_REPLY_ERROR", "–û—à–∏–±–∫–∞: –Ω–µ –Ω–∞–π–¥–µ–Ω ID —Ç–∏–∫–µ—Ç–∞."))
        await state.clear()
        return
    
    try:
        ticket = await TicketCRUD.get_ticket_by_id(db, ticket_id, load_messages=False)
        if not ticket:
            texts = get_texts(db_user.language)
            await message.answer(texts.t("TICKET_NOT_FOUND", "–¢–∏–∫–µ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω."))
            await state.clear()
            return
        
        until = datetime.utcnow() + timedelta(minutes=minutes)
        ok = await TicketCRUD.set_user_reply_block(db, ticket_id, permanent=False, until=until)
        if ok:
            await message.answer(f"‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω –Ω–∞ {minutes} –º–∏–Ω—É—Ç")
        else:
            await message.answer("‚ùå –û—à–∏–±–∫–∞ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏")
        await state.clear()
        await message.answer(
            "‚úÖ –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞. –û—Ç–∫—Ä–æ–π—Ç–µ —Ç–∏–∫–µ—Ç –∑–∞–Ω–æ–≤–æ –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è.",
            reply_markup=types.InlineKeyboardMarkup(inline_keyboard=[[types.InlineKeyboardButton(text="üëÅÔ∏è –ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Ç–∏–∫–µ—Ç", callback_data=f"admin_view_ticket_{ticket_id}")]])
        )
    except Exception as e:
        logger.error(f"Error setting block duration: {e}")
        texts = get_texts(db_user.language)
        await message.answer(texts.t("TICKET_REPLY_ERROR", "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."))


 


 

async def unblock_user_in_ticket(
    callback: types.CallbackQuery,
    db_user: User,
    db: AsyncSession
):
    try:
        ticket_id = extract_id_from_callback(callback.data)
    except ValueError:
        texts = get_texts(db_user.language)
        await callback.answer(texts.t("TICKET_NOT_FOUND", "–¢–∏–∫–µ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω."), show_alert=True)
        return
    ok = await TicketCRUD.set_user_reply_block(db, ticket_id, permanent=False, until=None)
    if ok:
        await callback.answer("‚úÖ –ë–ª–æ–∫ —Å–Ω—è—Ç")
        await view_admin_ticket(callback, db_user, db, FSMContext(callback.bot, callback.from_user.id))
    else:
        await callback.answer("‚ùå –û—à–∏–±–∫–∞", show_alert=True)


async def block_user_permanently(
    callback: types.CallbackQuery,
    db_user: User,
    db: AsyncSession
):
    try:
        ticket_id = extract_id_from_callback(callback.data)
    except ValueError:
        texts = get_texts(db_user.language)
        await callback.answer(texts.t("TICKET_NOT_FOUND", "–¢–∏–∫–µ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω."), show_alert=True)
        return
    ok = await TicketCRUD.set_user_reply_block(db, ticket_id, permanent=True, until=None)
    if ok:
        await callback.answer("‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω –Ω–∞–≤—Å–µ–≥–¥–∞")
        await view_admin_ticket(callback, db_user, db, FSMContext(callback.bot, callback.from_user.id))
    else:
        await callback.answer("‚ùå –û—à–∏–±–∫–∞", show_alert=True)


async def notify_user_about_ticket_reply(bot: Bot, ticket: Ticket, reply_text: str, db: AsyncSession):
    """–£–≤–µ–¥–æ–º–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –æ –Ω–æ–≤–æ–º –æ—Ç–≤–µ—Ç–µ –≤ —Ç–∏–∫–µ—Ç–µ"""
    try:
        from app.localization.texts import get_texts
        
        # –ü–æ–ª—É—á–∞–µ–º —Ç–∏–∫–µ—Ç —Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º
        ticket_with_user = await TicketCRUD.get_ticket_by_id(db, ticket.id, load_user=True)
        if not ticket_with_user or not ticket_with_user.user:
            logger.error(f"User not found for ticket #{ticket.id}")
            return
        
        texts = get_texts(ticket_with_user.user.language)
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
        base_text = texts.t(
            "TICKET_REPLY_NOTIFICATION", 
            "üé´ –ü–æ–ª—É—á–µ–Ω –æ—Ç–≤–µ—Ç –ø–æ —Ç–∏–∫–µ—Ç—É #{ticket_id}\n\n{reply_preview}\n\n–ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ, —á—Ç–æ–±—ã –ø–µ—Ä–µ–π—Ç–∏ –∫ —Ç–∏–∫–µ—Ç—É:"
        ).format(
            ticket_id=ticket.id,
            reply_preview=reply_text[:100] + "..." if len(reply_text) > 100 else reply_text
        )
        # –ï—Å–ª–∏ –±—ã–ª–æ —Ñ–æ—Ç–æ –≤ –ø–æ—Å–ª–µ–¥–Ω–µ–º –æ—Ç–≤–µ—Ç–µ –∞–¥–º–∏–Ω–∞ ‚Äî –æ—Ç–ø—Ä–∞–≤–∏–º –∫–∞–∫ —Ñ–æ—Ç–æ
        last_message = await TicketMessageCRUD.get_last_message(db, ticket.id)
        if last_message and last_message.has_media and last_message.media_type == "photo" and last_message.is_from_admin:
            caption = base_text
            try:
                await bot.send_photo(
                    chat_id=ticket_with_user.user.telegram_id,
                    photo=last_message.media_file_id,
                    caption=caption,
                    reply_markup=types.InlineKeyboardMarkup(inline_keyboard=[
                        [types.InlineKeyboardButton(text=texts.t("VIEW_TICKET", "üëÅÔ∏è –ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Ç–∏–∫–µ—Ç"), callback_data=f"view_ticket_{ticket.id}")],
                        [types.InlineKeyboardButton(text=texts.t("CLOSE_NOTIFICATION", "‚ùå –ó–∞–∫—Ä—ã—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ"), callback_data=f"close_ticket_notification_{ticket.id}")]
                    ])
                )
                return
            except Exception as e:
                logger.error(f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ñ–æ—Ç–æ-—É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ: {e}")
        # –§–æ–ª–ª–±–µ–∫: —Ç–µ–∫—Å—Ç–æ–≤–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
        await bot.send_message(
            chat_id=ticket_with_user.user.telegram_id,
            text=base_text,
            reply_markup=types.InlineKeyboardMarkup(inline_keyboard=[
                [types.InlineKeyboardButton(text=texts.t("VIEW_TICKET", "üëÅÔ∏è –ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Ç–∏–∫–µ—Ç"), callback_data=f"view_ticket_{ticket.id}")],
                [types.InlineKeyboardButton(text=texts.t("CLOSE_NOTIFICATION", "‚ùå –ó–∞–∫—Ä—ã—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ"), callback_data=f"close_ticket_notification_{ticket.id}")]
            ])
        )
        
        logger.info(f"Ticket #{ticket.id} reply notification sent to user {ticket_with_user.user.telegram_id}")
        
    except Exception as e:
        logger.error(f"Error notifying user about ticket reply: {e}")


def register_handlers(dp: Dispatcher):
    """–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –∞–¥–º–∏–Ω—Å–∫–∏—Ö –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ —Ç–∏–∫–µ—Ç–æ–≤"""
    
    # –ü—Ä–æ—Å–º–æ—Ç—Ä —Ç–∏–∫–µ—Ç–æ–≤
    dp.callback_query.register(show_admin_tickets, F.data == "admin_tickets")
    dp.callback_query.register(show_admin_tickets, F.data == "admin_tickets_scope_open")
    dp.callback_query.register(show_admin_tickets, F.data == "admin_tickets_scope_closed")
    
    dp.callback_query.register(view_admin_ticket, F.data.startswith("admin_view_ticket_"))
    
    # –û—Ç–≤–µ—Ç—ã –Ω–∞ —Ç–∏–∫–µ—Ç—ã
    dp.callback_query.register(
        reply_to_admin_ticket,
        F.data.startswith("admin_reply_ticket_")
    )
    
    dp.message.register(handle_admin_ticket_reply, AdminTicketStates.waiting_for_reply)
    dp.message.register(handle_admin_block_duration_input, AdminTicketStates.waiting_for_block_duration)
    
    # –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞–º–∏: —è–≤–Ω–∞—è –∫–Ω–æ–ø–∫–∞ –±–æ–ª—å—à–µ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è (—Å—Ç–∞—Ç—É—Å –º–µ–Ω—è–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏)
    
    dp.callback_query.register(
        close_admin_ticket,
        F.data.startswith("admin_close_ticket_")
    )
    dp.callback_query.register(block_user_in_ticket, F.data.startswith("admin_block_user_ticket_"))
    dp.callback_query.register(unblock_user_in_ticket, F.data.startswith("admin_unblock_user_ticket_"))
    dp.callback_query.register(block_user_permanently, F.data.startswith("admin_block_user_perm_ticket_"))
    
    # –û—Ç–º–µ–Ω–∞ –æ–ø–µ—Ä–∞—Ü–∏–π
    dp.callback_query.register(
        cancel_admin_ticket_reply,
        F.data == "cancel_admin_ticket_reply"
    )
    
    # –ü–∞–≥–∏–Ω–∞—Ü–∏—è –∞–¥–º–∏–Ω—Å–∫–∏—Ö —Ç–∏–∫–µ—Ç–æ–≤
    dp.callback_query.register(show_admin_tickets, F.data.startswith("admin_tickets_page_"))

    # –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–æ–º–ø–æ–Ω–æ–≤–∫–æ–π –æ—Ç–≤–µ—Ç–∞ ‚Äî (–æ—Ç–∫–ª—é—á–µ–Ω–æ)

    # –í–ª–æ–∂–µ–Ω–∏—è –≤ —Ç–∏–∫–µ—Ç–µ (–∞–¥–º–∏–Ω)
    async def send_admin_ticket_attachments(
        callback: types.CallbackQuery,
        db_user: User,
        db: AsyncSession
    ):
        texts = get_texts(db_user.language)
        try:
            ticket_id = extract_id_from_callback(callback.data)
        except ValueError:
            await callback.answer(texts.t("TICKET_NOT_FOUND", "–¢–∏–∫–µ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω."), show_alert=True)
            return
        ticket = await TicketCRUD.get_ticket_by_id(db, ticket_id, load_messages=True)
        if not ticket:
            await callback.answer(texts.t("TICKET_NOT_FOUND", "–¢–∏–∫–µ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω."), show_alert=True)
            return
        photos = [m.media_file_id for m in ticket.messages if getattr(m, "has_media", False) and getattr(m, "media_type", None) == "photo" and m.media_file_id]
        if not photos:
            await callback.answer(texts.t("NO_ATTACHMENTS", "–í–ª–æ–∂–µ–Ω–∏–π –Ω–µ—Ç."), show_alert=True)
            return
        from aiogram.types import InputMediaPhoto
        chunks = [photos[i:i+10] for i in range(0, len(photos), 10)]
        last_group_message = None
        for chunk in chunks:
            media = [InputMediaPhoto(media=pid) for pid in chunk]
            try:
                messages = await callback.message.bot.send_media_group(chat_id=callback.from_user.id, media=media)
                if messages:
                    last_group_message = messages[-1]
            except Exception:
                pass
        # –ü–æ—Å–ª–µ –æ—Ç–ø—Ä–∞–≤–∫–∏ –¥–æ–±–∞–≤–∏–º –∫–Ω–æ–ø–∫—É —É–¥–∞–ª–∏—Ç—å –ø–æ–¥ –ø–æ—Å–ª–µ–¥–Ω–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º –≥—Ä—É–ø–ø—ã
        if last_group_message:
            try:
                kb = types.InlineKeyboardMarkup(inline_keyboard=[[types.InlineKeyboardButton(text=texts.t("DELETE_MESSAGE", "üóë –£–¥–∞–ª–∏—Ç—å"), callback_data=f"admin_delete_message_{last_group_message.message_id}")]])
                await callback.message.bot.send_message(chat_id=callback.from_user.id, text=texts.t("ATTACHMENTS_SENT", "–í–ª–æ–∂–µ–Ω–∏—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã."), reply_markup=kb)
            except Exception:
                await callback.answer(texts.t("ATTACHMENTS_SENT", "–í–ª–æ–∂–µ–Ω–∏—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã."))
        else:
            await callback.answer(texts.t("ATTACHMENTS_SENT", "–í–ª–æ–∂–µ–Ω–∏—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã."))

    dp.callback_query.register(send_admin_ticket_attachments, F.data.startswith("admin_ticket_attachments_"))

    async def admin_delete_message(
        callback: types.CallbackQuery
    ):
        try:
            msg_id = extract_id_from_callback(callback.data)
        except ValueError:
            await callback.answer("‚ùå")
            return
        try:
            await callback.message.bot.delete_message(chat_id=callback.from_user.id, message_id=msg_id)
            await callback.message.delete()
        except Exception:
            pass
        await callback.answer("‚úÖ")

    dp.callback_query.register(admin_delete_message, F.data.startswith("admin_delete_message_"))

